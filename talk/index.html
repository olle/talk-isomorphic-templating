<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Homogenous Templating - FTW!</title>
  <meta name="description" content="An introduction to the Yeoman, Bower and Grunt toolset.">
  <meta name="author" content="Olle Törnström - toernstroem@synyx.de">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="../bower_components/reveal.js/css/reveal.min.css">
  <link rel="stylesheet" href="../bower_components/reveal.js/css/theme/blood.css" id="theme">
  <link rel="stylesheet" href="../bower_components/reveal.js/lib/css/zenburn.css">

  <!-- If the query includes 'print-pdf', use the PDF print sheet -->
  <script>
    document.write('<link rel="stylesheet" href="../bower_components/reveal.js/css/print/' + (window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper') + '.css" type="text/css" media="print">');
  </script>

  <!--[if lt IE 9]>
  <script src="../bower_components/reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <div class="reveal">
    <div class="slides">


      <section>
        <h1>Welcome!</h1>
        <p>
          DISCLAIMER: this presentation may contain strongly opinionated views,
          philosophical tech-rants, very little science and possibly traces of
          <em>nuts</em>.
        </p>
      </section>


      <section>
        <h1>Homogenous Templating</h1>
        <aside class="notes">
          This talk is about the use of templating in web applications, and how
          it can be set up to allow the use of the same tool both on the server-
          and client-side.
        </aside>
      </section>


      <section>
          <h3>template <small>|ˈtɛmpleɪt, -plɪt|</small></h3>
          <p>a shaped piece of rigid material used as a pattern for processes such as cutting out, shaping, or drilling.</p>
        <aside class="notes">
          Templating can mean different things to different people.
        </aside>
      </section>


      <section>
        <img src="img/templating.jpg" />
        <aside class="notes">
          This is not what we mean.
        </aside>
      </section>


      <section>
        <h3>In ur strz, interpolejtin!</h3>
        <pre><code data-trim>
Hello ${name}!
        </code></pre>
        <aside class="notes">
          When we say templating, we generally mean string interpolation or the
          ability to separate the content from the presentation.
        </aside>
      </section>


      <section>
        <h3>Dynamic Server Pages</h3>
        <img src="img/webserver.jpg" />
        <aside class="notes">
          Initially the web was state-less and pure. Pages were interpolated or
          rendered only on the server side.
        </aside>
      </section>


      <section>
        <h2>Templating v1.0</h2>
        <img src="img/serverpageswars.png" />
        <aside class="notes">
          Though there was a pretty common view on how to actually do templating
          or interpolation between the available platforms.
        </aside>
      </section>


      <section>
        <h2>ASP</h2>
        <pre><code data-trim class="asp">
          <p>Hello <%= name %>!</p>
        </code></pre>
        <aside class="notes">
          This is classic active server pages templating.
        </aside>
      </section>


      <section>
        <h2>JSP</h2>
        <pre><code data-trim class="asp">
<p>Hello <%= name %>!</p>
        </code></pre>
        <aside class="notes">
          This JSP expression example uses the exact same syntax.
        </aside>
      </section>


      <section>
        <h2>PHP</h2>
        <pre><code data-trim class="php">
&lt;p&gt; Hello &lt;?= $name ?&gt;!&lt;/p&gt;
        </code></pre>
        <aside class="notes">
          The PHP example is also very simliar.
        </aside>
      </section>


      <section>
        <h1>XML/XSLT</h1>
        <img src="img/notlistening.png" />
        <aside class="notes">
          Of course there were other ways to generate dynamic content, and
          perhaps even better, or at least more formal, than simple string
          interpolation.
        </aside>
      </section>


      <section>
        <h2>Can haz moar puwr!</h2>
        <img src="img/js-performance-over-time.png" />
        <aside class="notes">
          Now let's fast forward into present time. Thanks to Moore's law, the
          client computer became faster. Web 2.0 and Ajax became a given
          extension to the old state-less model.
        </aside>
      </section>


      <section>
        <h3>Templating v1.9</h3>
        <pre><code data-trim class="javascript">
$('#greeting').append('<p>Hello' + name + '</p>');
        </code></pre>
        <aside class="notes">
          It was easy to go for a quick-and-dirty solution.
        </aside>
      </section>


      <section>
        <h1>Bad idea</h1>
        <img src="img/badidea.jpg" />
        <aside class="notes">
          But as projects grew on the client-side, so did the motivation for
          client-side templating.
        </aside>
      </section>


      <section>
        <h3>Templating v2.0</h3>
        <img src="img/js-templating-v1.png" />
        <aside class="notes">
          Resulting in a lot of neat templating solutions for the client-side.
        </aside>
      </section>


      <section>
        <h2>Templating v3.0!</h2>
        <img src="img/js-templating-v2.png" />
        <aside class="notes">
          Or why not for both the server and the client!
        </aside>
      </section>


      <section>
        <h2>Example</h2>
        <p>Server- and client-side templating with Spring MVC and Mustache.</p>
      </section>


      <section>
        <h3>Dependencies</h3>
        <pre><code data-trim class="xml">
<dependency>
  <groupId>com.github.sps.mustache</groupId>
  <artifactId>mustache-spring-view</artifactId>
  <version>1.3</version>
</dependency>
<dependency>
  <groupId>com.samskivert</groupId>
  <artifactId>jmustache</artifactId>
  <version>1.9</version>
</dependency>
        </code></pre>
      </section>

      <section>
        <h3>Project layout</h3>
        <pre><code data-trim>
src/main
    ├── java
    │   └── ...
    └── webapp
        ├── WEB-INF/
        ├── assets
        │   ├── jquery/
        │   └── mustache/
        ├── css/
        ├── img/
        └── templates
            ├── index.mustache
            └── person.mustache
        </code></pre>
      </section>


      <section>
        <h3>Config</h3>
        <pre><code data-trim class="java">
...
@Configuration
@EnableWebMvc
@ComponentScan(basePackages = { "webapp" })
public class WebAppConfig extends WebMvcConfigurerAdapter {

  @Override
  public void addResourceHandlers(ResourceHandlerRegistry reg) {

    reg.addResourceHandler("/templates/**").addResourceLocations("/templates/");
    reg.addResourceHandler("/assets/**").addResourceLocations("/assets/");
    reg.addResourceHandler("/css/**").addResourceLocations("/css/");
    reg.addResourceHandler("/img/**").addResourceLocations("/img/");
  }
  ...
        </code></pre>
      </section>


      <section>
        <h3>View resolver</h3>
        <pre><code data-trim class="java">
...
@Bean
public ViewResolver viewResolver() {

  MustacheViewResolver viewResolver = new MustacheViewResolver();
  viewResolver.setCache(false); // development only
  viewResolver.setTemplateFactory(templateFactory());

  return viewResolver;
}
...
        </code></pre>
        </section>


        <section>
          <h3>Template factory</h3>
          <pre><code data-trim class="java">
...
@Bean
public JMustacheTemplateFactory templateFactory() {

  JMustacheTemplateFactory templateFactory = new JMustacheTemplateFactory();
  templateFactory.setTemplateLoader(templateLoader());
  templateFactory.setPrefix("/templates/");
  templateFactory.setSuffix(".mustache");

  return templateFactory;
}
...
          </code></pre>
        </section>


      <section>
        <h3>Controller</h3>
        <pre><code data-trim class="java">
...
@Controller
public class Index {

  @RequestMapping(value = "/")
  public ModelAndView displayIndexPage(Model model) {

    model.addAttribute("greeting", "Hello from Mustache!");

    People.addPeople(model);

    return new ModelAndView("index", model.asMap());
  }
  ...
        </code></pre>
      </section>





      <section>
        <h3>People</h3>
        <pre><code data-trim class="java">
...
public class People {

  public static void addPeople(Model model) {

    Person ruby = new Person("Ruby Heckler", 32);
    Person bernhard = new Person("Bernhard Klein", 55);
    Person trogdor = new Person("Trogdor", 3221);

    model.addAttribute("people", Arrays.asList(ruby, bernhard, trogdor));
  }
...
        </code></pre>
      </section>


      <section>
        <h3>Index template</h3>
        <pre><code data-trim>
...
&lt;body&gt;
  &lt;header class="container"&gt;
    &lt;h1&gt;{{greeting}}&lt;/h1&gt;
  &lt;/header&gt;
  &lt;section class="container"&gt;
    &lt;h2&gt;People:&lt;/h2&gt;
    &lt;ul id="people"&gt;
    {{#people}}
      {{&gt; person}} <!-- Partial yay! -->
    {{/people}}
    &lt;/ul&gt;
...
        </code></pre>
      </section>


      <section>
        <h3>Person template</h3>
        <pre><code data-trim>
&lt;li&gt;
  &lt;strong&gt;Name:&lt;/strong&gt; {{name}}
  &lt;strong&gt;Age:&lt;/strong&gt; {{age}}
&lt;/li&gt;
        </code></pre>
      </section>


      <section>
        <h1>Demo</h1>
      </section>

    </div>
  </div>

  <script src="../bower_components/reveal.js/lib/js/head.min.js"></script>
  <script src="../bower_components/reveal.js/js/reveal.min.js"></script>
  <script>
    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition: Reveal.getQueryHash().transition || 'concave', // default/cube/page/concave/zoom/linear/fade/none

      // Parallax scrolling
      parallaxBackgroundImage: 'img/reveal-parallax-1.jpg',
      parallaxBackgroundSize: '2100px 900px',

      // Optional libraries used to extend on reveal.js
      dependencies: [{
        src: '../bower_components/reveal.js/lib/js/classList.js',
        condition: function() {
          return !document.body.classList;
        }
      }, {
        src: '../bower_components/reveal.js/plugin/highlight/highlight.js',
        async: true,
        callback: function() {
          hljs.initHighlightingOnLoad();
        }
      }, {
        src: '../bower_components/reveal.js/plugin/notes/notes.js',
        async: true,
        condition: function() {
          return !!document.body.classList;
        }
      }]
    });
  </script>
</body>

</html>
